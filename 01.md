## 프로세스와 쓰레드

### 프로그램과 프로세스

프로그램

- 저장장치(HDD, SSD)에 저장된 명령문의 집합체
- 애플리케이션이나 앱이라고도 불리고 윈도우즈에서는 .exe 파일의 모습
- 컴퓨터 입장에서 프로그램은 저장 장치만 사용하는 수동적인 존재

프로세스

- 실행중인 프로그램(하드디스크에 저장된 프로그램이 메모리에 올라갔을 때 )
- 메모리 사용하고 운영체제의 CPU스케줄링 알고리즘에 따라서 CPU도 사용하고 필요에 따라 입력과 출력을 하기 때문에 능동적인 존재

프로세스의 구조

CODE - 자신을 실행하는 코드가 저장

DATA - 전역 변수와 Static(정적) 변수가 저장

HEAP - 프로그래머가 동적으로 메모리를 할당하는 데 쓰임

STACK - 지역 변수와 함수 호출을 했을 때 필요한 정보들이 저장

컴파일 과정

1. 전처리기를 거쳐서 매크로로 정의한 숫자를 치환하고 필요한 파일을 불러옴
2. 전처리기를 거치면 파일의 확장자는 .i가 됨
3. 컴파일러가 컴파일을 해 줌
4. 컴파일을 마치면 고수준인 C언어를 저수준인 어셈블리어로 바꿔줌 (어셈블리어는 명령어가 기계어랑 일대일 매칭이 되서 기계어랑 가장 가까움)
5. 컴파일러를 거치면 파일의 확장자는 .s가 됨
6. 어셈블러가 어셈블리어를 기계어로 바꿔줌
7. 파일의 확장자가 .o가 됨
8. 링커가 라이브러리나 다른 소스코드를 연결
9. 파일의 확장자가 .exe가 됨
10. 파일을 더블클릭하면 .exe 파일이 메모리에 올라가고 올라간 프로그램은 프로세스라고 불림

- 프로세스는 운영체제에 의해 관리된다

### 멀티프로그래밍과 멀티프로세싱

유니프로그래밍

- 메모리에 오직 하나의 프로세스가 올라온 것

멀티프로그래밍

- 메모리에 여러 개의 프로세스가 올라온 것

멀티프로세싱

- CPU가 여러 개의 프로세스를 처리하는 것

OS는 멀티프로그래밍과 멀티프로세싱이 공존

### PCB(Process Control Block)

프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고 있는 PCB를 만들고 저장 

PCB는 연결리스트라는 자료구조로 저장

연결리스트는 각각의 데이터가 다음 데이터를 연결하는 구조로 되어있는 자료구조

PCB구조

- 포인터
    
    부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터등이 있고 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있음
    
- 프로세스 상태
    
     생성, 준비, 실행, 대기, 완료
    
- 프로세스 ID
    
    프로세스를 식별하기 위한 숫자가 저장
    
- 프로그램 카운터
    
    다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터를 저장
    
- 레지스터 정보
    
    프로그램 카운터와 마찬가지로 CPU를 뺏기고 다시 시작할 때 이전에 사용하던 값을 복구하기 위한 용도
    
- 메모리 관련 정보
    
    프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기 위한 경계레지스터 값 등이 저장
    
- CPU 스케줄링 정보
    
    CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유시간등이 저장
    

시분할 시스템을 위해 프로세스는 상태를 가지고 있음

생성상태

- PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태

준비상태

- CPU를 사용하기 위해 기다리고 있는 상태, 대부분의 프로세스는 준비상태

실행상태

- 준비상태에 있는 프로세스가 CPU스케줄러에 의해 CPU를 할당받아 실행되는 상태, 실행상태에 있는 프로세스의 수는 CPU의 개수랑 동일, 부여된 시간만큼만 사용 가능 초과한다면 할당된 CPU를 강제로 빼앗음

대기상태

- 프로세스가 입출력 요청을하면 입출력이 완료될 때까지 기다리는 상태

완료상태

- 프로세스가 종료된 상태
- 프로세스가 사용했던 데이터를 메모리에서 제거하고 생성된 PCB도 제거

### 컨텍스트 스위칭

프로세스를 실행하는중에 다른 프로세스를 실행하기 위해 실행중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업

컨텍스트 스위칭이 일어날 때 PCB의 내용이 변경되는데 그 값에는 프로세스 상태, 프로그램 카운터, 레지스터 값이 있음

메모리에 있는 모든 프로세스들은 컨텍스트 스위칭을 함

컨텍스트 스위칭을 하는 이유는 다양한데 CPU 점유시간이 다 되거나, I/O 요청이 있거나 다른 종류의 인터럽트가 있을 때 발생함

### 프로세스 생성과 종료

.exe 파일을 더블클릭으로 실행하면 운영체제는 해당 프로그램의 코드영역과 데이터영역을 메모리에 로드하고 빈 스택과 빈 힙을 만들어 공간을 확보함 → 프로세스를 관리할 PCB를 만들어 값을 초기화함

운영체제가 부팅되고 0번 프로세스가 생성될 때 딱 한 번만 실행

나머지 프로세스는 0번 프로세스를 복사해서 씀 복사는 fork() 함수를 이용

→ 새로 생성하는 것보다 복사가 더 빠름

exec() 함수
- 부모를 복사한 자식 프로세스의 코드와 데이터 영역을 원하는 값으로 덮어씀

wait() 함수
- 자식 프로세스에게서 exit() 신호가 올 때까지 기다리는 시스템 함수

exit() 함수
- 자식 프로세스가 부모 프로세스에게 정상종료를 알리는 함수

좀비 프로세스
- 부모프로세스가 먼저 종료되거나 자식프로세스가 비정상적으로 종료되어 exit() 신호를 주지못해서 Exit Status를 읽지 못해 메모리에 계속 살아있는 상태

### 쓰레드

프로세스내에 존재하는 것으로 1개 이상이 있을 수 있음

PCB, 코드, 데이터, 힙영역을 공유

쓰레드를 관리하는 TCB가 생김

장단점

1. 안전성

 - 프로세스는 독립적이기 때문에 하나의 프로세스가 문제가 있더라도 다른 프로세스의 영향이 없음

 - 쓰레드는 프로세스를 공유하고 있어 문제가 생기면 모든 쓰레드에 영향을 줌

2. 속도와 자원

- 프로세스는 오버헤드가 크고 속도가 느림

- 쓰레드는 오버헤드가 작음
# 그림으로 쉽게 배우는 운영체제

## 운영체제 들어가기

### 운영체제 개요

컴퓨터는 운영체제가 없어도 동작

But, 운영체제가 없으면 다른 기능을 추가할 수 없음

**운영체제가 하는 일**

1. 프로세스 관리

- 운영체제가 관리하지 않으면 브라우저가 CPU를 독차지해서 여러 개의 프로그램이 실행되지 않음

2. 메모리 관리

- 모든 프로그램은 메모리에 올라와서 동작

3. 하드웨어 관리

- 운영체제는 사용자의 하드웨어에 대한 직접적인 접근을 막음

4. 파일 시스템 관리

### 운영체제의 역사

1940년도 - 컴퓨터의 최초의 목적은 미사일 탄도 계산, 에니악은 특정 명령에 맞는 스위치와 배선을 연결해서 프로그래밍함. 입출력을 위해 IBM 펀치 카드를 이용.입출력 속도가 굉장히 느리고 입출력 도중에는 계산을 할 수 없음

1950년도 - 직접회로가 개발, 현대적인 컴퓨터의 모습을 갖춤, 펀치 카드를 이용해 프로그램을 작성

1950년도 중후반 - 오퍼레이터가 한 번에 모아서 순서대로 실행해 CPU가 한 번에 결과를 보여줌. 이를 싱글스트림 배치시스템이라고 함. 입출력 작업을 하는 동안에는 CPU를 사용할 수 없었는데 I/O 디바이스 컨트롤러를 만들어 입출력 중에도 CPU가 계산할 수 있도록 만듦. I/O 디바이스 컨트롤러는 입출력 작업이 끝나면 CPU에게 인터럽트 신호를 주고 인터럽트를 받은 CPU는 다시 처리를 하는 식으로 발전

1960년도 - 싱글스트림 배치시스템의 한계를 극복 , 메모리에 여러 프로그램을 올려놓고 시간을 나누어서 실행 → 시분할 시스템

C언어로 유닉스 운영체제를 개발 - 멀티 프로그래밍, 다중 사용자, 파일 시스템 구현한 운영체제

여러 프로그램을 동시에 실행하니 문제가 발생

메모리에 여러 프로그램이 올라와서 작업을 실행하기 때문에 메모리 침범 이슈가 생김

기존에는 프로그램을 작성할 때 메모리에는 프로그램이 하나가 있기 때문에 메모리 주소를 프로그램이 하나라고 가정하고 프로그래밍을 했는데 여러 개가 올라가니 어느 위치에서 시작하는지 모름 → 하드웨어적으로 베이스 레지스터라는 것을 추가해 프로그램의 시작 주소를 저장하고 모든 프로그램은 0번지에서 실행한다고 가정하게 됨

1970년도 이후 - 개인용 컴퓨터의 시작

### 운영체제의 구조

운영체제의 핵심은 **커널**

커널은 프로세스와 메모리, 저장장치를 관리하는 핵심적인 기능을 담당

사용자는 운영 체제의 커널에 직접 접근할 수 없고 인터페이스를 통해서 접근할 수 있다

인터페이스

- GUI(Graphic User Interface)
- CLI(Command-Line Interface)
  유닉스나 리눅스 같은 운영체제가 기본적으로 제공하는 인터페이스
  텍스트를 이용해 커널과 상호 작용
  시스템 콜을 이용하면 커널에서 제공하는 Write 함수를 쓰게 되는데 그럼 운영체제가 알아서 하드디스크의 빈 공간에 저장함
  하드웨어와 커널의 인터페이스로는 드라이버를 사용함

### 컴퓨터 하드웨어와 구조

폰 노이만 구조

CPU와 메모리

버스 - 데이터를 전달하는 통로

CPU(Central Processing Unit 중앙처리장치) 구조

1. 산술논리 연산장치

- 데이터 연산 담당

2. 제어장치

- 모든 장치들의 동작을 지시하고 제어하는 장치

3. 레지스터

- CPU내에서 계산을 위해 임시로 보관하는 장치, 변수라고 생각하면 됨

메모리 종류

RAM(Random Access Memory)

- 랜덤으로 데이터를 읽어도 저장된 위치와 상관 없이 읽는 속도가 같음
- 전력이 끊기면 데이터를 잃어버리기 때문에 메인 메모리로 사용

ROM(Read Only Memory)

- 전력이 끊겨도 데이터를 계속 보관할 수 있지만 데이터를 한 번 쓰면 수정이 불가능
- 컴퓨터의 부팅과 관련된 바이오스를 저장하는 데 주로 쓰임

### 컴퓨터의 부팅과정

- 컴퓨터의 전원을 누르면 ROM에 저장된 바이오스가 실행

- 바이오스

1. 전원, CPU, 메모리, 키보드, 마우스, 하드디스크 등 주요 하드웨어에 이상이 없는지 체크

2. 이상이 없다면 하드디스크에 있는 마스터 부트 레코드에 저장된 부트로더를 메모리로 가져와서 실행

3. 만약 운영체제가 두 개라면 운영체제 선택하는 화면이 나옴. 운영체제를 선택했거나 운영체제가 하나면 바로 운영체제를 메모리로 불러와 바탕 화면이 보이게 됨

### 인터럽트

폴링 방식

- CPU는 입출력 작업이 들어오면 입출력 관리자에게 입출력 명령을 내림
- CPU관점에서는 입출력 명령이 언제 완료되는지 알 수 없어 완료 확인할 때까지 계속 확인함
- 폴링 방식은 성능이 좋지 않음

인터럽트는 폴링 방식의 단점을 해결

CPU가 입출력 관리자에게 입출력 명령을 내리고 다른 작업을 계속함

입출력 관리자는 입출력이 완료되었을 때 CPU에게 신호를 주고 CPU는 신호를 받아 인터럽트 서비스 루틴(ISR)을 실행시켜 작업을 완료

**인터럽트 서비스 루틴(ISR)**

특정 인터럽트가 들어오면 그 인터럽트를 처리하는 함수

비동기적으로 동작하기 때문에 성능에 이점

1. 하드웨어 인터럽트 (입출력)
2. 소프트웨어 인터럽트

- 사용자 프로그램에서 발생한 인터럽트
- 유효하지 않은 메모리에 접근하거나 0으로 나누는 명령어
